---
import Layout from '../../layouts/Layout.astro';
import { stapiService, getStaticImage } from '../../services/stapiService';

// Pagination settings
const PAGE_SIZE = 48; // Number of characters to display per page
let initialCharacters = [];
let totalPages = 1;
let totalCharacters = 0;
let allSpecies = []; // For filter dropdown

// Fetch only the first page of characters for the initial build
try {
  const initialData = await stapiService.getCharacters(0, PAGE_SIZE);
  initialCharacters = initialData.characters || [];
  totalPages = initialData.page?.totalPages || 1;
  totalCharacters = initialData.page?.totalElements || initialCharacters.length;

  // Fetch all species for the filter dropdown (consider caching this later)
  // This might still be slow if there are thousands of species
  const speciesData = await stapiService.searchSpecies({ pageSize: 2000 }); // Adjust pageSize as needed
  allSpecies = speciesData.map(s => s.name).sort((a, b) => {
    if (a === 'Human') return -1;
    if (b === 'Human') return 1;
    if (a === 'Unknown') return -1; // Assuming 'Unknown' might exist
    if (b === 'Unknown') return 1;
    return a.localeCompare(b);
  });

  console.log(`Initial build: Fetched ${initialCharacters.length} characters. Total characters: ${totalCharacters}, Total pages: ${totalPages}. Found ${allSpecies.length} species.`);

} catch (error) {
  console.error('Error fetching initial character/species data:', error);
  // Add fallback data if needed
  initialCharacters = [ /* Add fallback character objects here if API fails */ ];
  allSpecies = ['Human', 'Vulcan', 'Klingon']; // Basic fallback species
  totalCharacters = initialCharacters.length;
  totalPages = 1;
}

// Extract ranks *only* from the initial page for the build
let initialRanks = [...new Set(initialCharacters
  .map(c => c.title?.trim())
  .filter(Boolean) // Remove empty/null titles
)].sort();


// --- REMOVED Memory Alpha image fetching and complex species grouping from build ---


// Create JSON-LD schema for characters page (using initial data)
const charactersSchema = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "name": "Star Trek Characters | Complete Guide to Characters in the Star Trek Universe",
  "description": "Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond.",
  "url": "https://star-trek-timelines.netlify.app/characters/",
  "isPartOf": {
    "@type": "WebSite",
    "name": "Star Trek Timelines",
    "url": "https://star-trek-timelines.netlify.app/"
  },
  "about": {
    "@type": "CreativeWorkSeries",
    "name": "Star Trek",
    "description": "Science fiction media franchise created by Gene Roddenberry"
  },
  // Update hasPart to use initialCharacters
  "hasPart": initialCharacters.slice(0, 10).map(char => ({ // Limit to first 10 for schema
      "@type": "Person",
      "name": char.name,
      // Ensure slug/uid exists for URL generation
      "url": `https://star-trek-timelines.netlify.app/characters/${char.uid}/`,
      "jobTitle": char.title || "Officer",
      // Try to get species name if available in character object
      "description": `${char.characterSpecies?.[0]?.name || char.species?.[0]?.name || 'Unknown'} character from Star Trek`
  }))
};
---

<Layout
  title="Star Trek Characters | Complete Guide to Characters in the Star Trek Universe"
  description="Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond."
  schemaData={charactersSchema}
>
  
  <div class="container mx-auto px-4 py-12">
    <div class="lcars-header mb-8">
      <div class="lcars-header-content">
        <h1 class="text-3xl">Federation Personnel Database</h1>
      </div>
    </div>
    
    <div class="lcars-panel mb-12">
      <div class="lcars-top-bar flex">
        <div class="w-32 h-8 bg-starfleet-gold rounded-tl-lg"></div>
        <div class="flex-1 h-8 bg-starfleet-blue"></div>
        <div class="w-16 h-8 bg-starfleet-red"></div>
      </div>
      
      <div class="panel-content p-6">
        <p class="text-gray-300 mb-6">
          Accessing Federation personnel records... This database contains information on notable individuals
          from across the Star Trek universe, organized by species and rank. Explore the profiles of Starfleet officers,
          diplomats, scientists, and others who have shaped the history of the galaxy.
        </p>
        
        <div class="filters mb-8">
          <div class="flex flex-wrap gap-4">
            <div class="filter-group">
              <h3 class="text-white text-lg mb-2">Filter by Species</h3>
              <select
                id="species-filter"
                class="appearance-none bg-space-black text-white p-2 pr-8 border border-starfleet-blue rounded relative"
              >
                <option value="all">All Species</option>
                {allSpecies.map(species => (
                                  <option value={species}>{species}</option>
                                ))}
              </select>
              <!-- chevron -->
              <svg class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 fill-starfleet-gold"
                   viewBox="0 0 20 20"><path d="M5 7l5 5 5-5H5z"/></svg>
            </div>
            
            {initialRanks.length > 0 && (
                          <div class="filter-group">
                            <h3 class="text-white text-lg mb-2">Filter by Rank</h3>
                            <select
                              id="rank-filter"
                              class="appearance-none bg-space-black text-white p-2 pr-8 border border-starfleet-blue rounded relative"
                            >
                              <option value="all">All Ranks</option>
                              {/* Populate ranks dynamically client-side later */}
                              {initialRanks.map(rank => (
                                <option value={rank}>{rank}</option>
                              ))}
                            </select>
                            <!-- chevron -->
                            <svg class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 fill-starfleet-gold"
                                 viewBox="0 0 20 20"><path d="M5 7l5 5 5-5H5z"/></svg>
                          </div>
                        )}
            
            <div class="filter-group ml-4">
              <h3 class="text-white text-lg mb-2">Show Only</h3>
              <div class="flex items-center">
                <input
                  type="checkbox"
                  id="important-filter"
                  class="mr-2"
                >
                <label for="important-filter" class="text-white">Important Characters</label>
              </div>
            </div>
            
            <div class="filter-group ml-auto">
              <h3 class="text-white text-lg mb-2">Search</h3>
              <input
                type="text"
                id="search-input"
                placeholder="Search characters..."
                class="appearance-none bg-space-black border border-starfleet-blue text-white p-2 rounded"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Characters container -->
    <div
      id="characters-container"
      class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"
    />
    
    <!-- Pagination controls -->
    <div class="flex justify-between items-center my-8">
      <div class="character-count px-3 py-1 bg-space-black rounded-full text-white text-sm" id="characters-count">
        {totalCharacters} characters
      </div>
      
      <div id="pagination-controls" class="flex justify-center items-center">
        <div class="lcars-pagination flex items-center bg-space-black border border-starfleet-blue rounded-lg overflow-hidden">
          <button id="prev-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Previous
          </button>
          <div class="px-4 py-2 text-white">
            Page <span id="current-page-num">1</span> of <span id="total-pages">{totalPages}</span>
          </div>
          <button id="next-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Next
          </button>
        </div>
      </div>
    </div>
    
    <!-- No results message (hidden by default) -->
    <div id="no-results" class="hidden text-center py-8">
      <div class="lcars-panel p-6 inline-block">
        <p class="text-console-blue text-xl">No characters match your search criteria.</p>
        <p class="text-white mt-2">Please adjust your filters or try a different search term.</p>
      </div>
    </div>
  </div>
</Layout>

<script
  id="initial-payload"
  type="application/json"
  set:html={JSON.stringify({
    characters: initialCharacters,
    totalPages: totalPages,
    totalCharacters: totalCharacters,
    pageSize: PAGE_SIZE,
    // Pass initial ranks too, species are already in the dropdown
    initialRanks: initialRanks
  })}
/>

<script>
  // Make stapiService available client-side (simplified version)
  const stapiClient = {
    BASE_URL: 'https://stapi.co/api/v1/rest',
    async getCharacters(page = 0, pageSize = 48) {
      try {
        // Construct URL properly
        const url = `${this.BASE_URL}/character/search?pageNumber=${page}&pageSize=${pageSize}`;
        console.log(`Fetching: ${url}`); // Log URL
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        console.log(`Received page ${page}:`, data); // Log received data
        return data; // Should contain { characters: [], page: { totalPages, totalElements } }
      } catch (error) {
        console.error('Error fetching characters client-side:', error);
        // Return an empty structure on error to prevent crashes
        return { characters: [], page: { totalPages: 1, totalElements: 0 } };
      }
    },
    // Add getMemoryAlphaContent client-side if needed for images, or handle in detail page
    async getMemoryAlphaImage(characterName) {
       // Basic example - might need a proxy function due to CORS
       try {
         const searchParams = new URLSearchParams({
           action: 'query',
           format: 'json',
           prop: 'pageimages',
           titles: characterName,
           pithumbsize: 200, // Adjust size as needed
           origin: '*' // Required for CORS from browser
         });
         const response = await fetch(`https://memory-alpha.fandom.com/api.php?${searchParams}`);
         if (!response.ok) throw new Error('MA API fetch failed');
         const data = await response.json();
         const page = Object.values(data.query.pages)[0];
         return page?.thumbnail?.source || null;
       } catch (error) {
         console.error(`Error fetching MA image for ${characterName}:`, error);
         return null;
       }
    }
  };


  document.addEventListener('DOMContentLoaded', () => {
    const payload = JSON.parse(document.getElementById('initial-payload').textContent);
    const PAGE_SIZE = payload.pageSize;
    let currentPage = 1;
    let totalPages = payload.totalPages;
    let totalCharacters = payload.totalCharacters;
    let allCharacters = [...payload.characters]; // Start with initial characters
    let loadedPages = new Set([0]); // Keep track of loaded pages (0-indexed)
    let isLoading = false; // Prevent multiple simultaneous fetches

    // DOM Elements
    const speciesFilter = document.getElementById('species-filter');
    const rankFilter = document.getElementById('rank-filter'); // Assuming rank filter exists
    const importantBox = document.getElementById('important-filter');
    const searchInput = document.getElementById('search-input');
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const pageNum = document.getElementById('current-page-num');
    const totalNum = document.getElementById('total-pages');
    const countBadge = document.getElementById('characters-count');
    const container = document.getElementById('characters-container');
    const noResults = document.getElementById('no-results');

    const debounce = (fn, ms = 300) => {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    };

    // Function to fetch a specific page if not already loaded
    async function fetchPageIfNeeded(pageNumber) { // pageNumber is 1-based for UI
      const pageIndex = pageNumber - 1; // API is 0-based
      if (loadedPages.has(pageIndex) || isLoading) {
        return; // Already loaded or loading
      }

      isLoading = true;
      // Show loading indicator (optional)
      container.style.opacity = '0.5';

      try {
        const data = await stapiClient.getCharacters(pageIndex, PAGE_SIZE);
        if (data.characters && data.characters.length > 0) {
          // Add new characters, avoiding duplicates (though API should handle this)
          const newChars = data.characters.filter(nc => !allCharacters.some(ac => ac.uid === nc.uid));
          allCharacters = [...allCharacters, ...newChars];
          loadedPages.add(pageIndex);

          // Update total pages/count if necessary (though initial payload should be accurate)
          if (data.page?.totalPages && data.page.totalPages !== totalPages) {
             totalPages = data.page.totalPages;
             totalNum.textContent = totalPages;
          }
           if (data.page?.totalElements && data.page.totalElements !== totalCharacters) {
             totalCharacters = data.page.totalElements;
             // Update count badge potentially, though filtering affects this more
          }

        } else {
          console.warn(`No characters returned for page ${pageIndex}`);
          // Add page index even if empty to prevent re-fetching
          loadedPages.add(pageIndex);
        }
      } catch (error) {
        console.error(`Failed to fetch page ${pageIndex}:`, error);
        // Handle error display if needed
      } finally {
        isLoading = false;
        container.style.opacity = '1';
        render(); // Re-render after fetching
      }
    }

    // Function to render the current page based on filters and loaded data
    async function render() {
      if (isLoading) return; // Don't render while loading

      const speciesVal = speciesFilter.value;
      const rankVal = rankFilter ? rankFilter.value : 'all'; // Handle if rank filter doesn't exist
      const importantOnly = importantBox.checked;
      const searchTerm = searchInput.value.trim().toLowerCase();

      // Filter the *currently loaded* characters
      let filteredList = allCharacters.filter(c => {
        const characterSpecies = c.characterSpecies?.[0]?.name || c.species?.[0]?.name || 'Unknown';
        const characterRank = c.title?.trim() || '';

        if (speciesVal !== 'all' && characterSpecies !== speciesVal) return false;
        if (rankVal !== 'all' && characterRank !== rankVal) return false;
        if (importantOnly && !c.isImportant) return false; // Assuming 'isImportant' property exists
        if (searchTerm && !c.name.toLowerCase().includes(searchTerm)) return false;
        return true;
      });

      // Update total count based on filter
      countBadge.textContent = `${filteredList.length} characters shown (of ${totalCharacters} total)`;

      // Calculate pagination based on the *filtered* list length
      const filteredTotalPages = Math.max(1, Math.ceil(filteredList.length / PAGE_SIZE));
      if (currentPage > filteredTotalPages) currentPage = filteredTotalPages;

      pageNum.textContent = currentPage;
      // Display total pages based on filtered results or overall total? Let's use filtered.
      totalNum.textContent = filteredTotalPages;

      // Enable/disable pagination buttons
      prevBtn.disabled = currentPage <= 1;
      nextBtn.disabled = currentPage >= filteredTotalPages;

      // Slice the filtered list for the current page view
      const start = (currentPage - 1) * PAGE_SIZE;
      const pageItems = filteredList.slice(start, start + PAGE_SIZE);

      // Display "No Results" message if needed
      noResults.classList.toggle('hidden', pageItems.length > 0);

      // Render character cards
      container.innerHTML = pageItems.map(c => {
         // Basic image handling - prefer wikiImage if fetched, fallback
         const imageUrl = c.wikiImage || c.image || '/images/generic-character.jpg';
         // Generate slug client-side if needed (ensure slugify utility is available or simplify)
         const slug = c.uid; // Use UID directly for simplicity now

         return `
           <div class="character-card bg-space-black border border-starfleet-blue rounded-lg overflow-hidden transition-transform hover:scale-105">
             <a href="/characters/${slug}/" class="block">
               <div class="character-image aspect-square bg-gray-800">
                 <img loading="lazy"
                      src="${imageUrl}"
                      alt="${c.name}"
                      class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"
                      onerror="this.onerror=null; this.src='/images/generic-character.jpg';" />
               </div>
               <div class="character-info p-3 border-t border-starfleet-blue">
                 <h3 class="text-white font-semibold truncate" title="${c.name}">${c.name}</h3>
                 <p class="text-gray-400 text-sm">${c.characterSpecies?.[0]?.name || c.species?.[0]?.name || 'Unknown'}</p>
               </div>
             </a>
           </div>
         `;
        }).join('');

        // Optional: Fetch Memory Alpha images for visible cards after rendering
        // This adds complexity but improves initial load
        /*
        const imagesToLoad = container.querySelectorAll('img[loading="lazy"]');
        imagesToLoad.forEach(async img => {
          if (!img.dataset.maChecked) {
             img.dataset.maChecked = true; // Prevent re-checking
             const characterName = img.alt;
             if (img.src.includes('generic-character')) { // Only fetch if using placeholder
                const maImage = await stapiClient.getMemoryAlphaImage(characterName);
                if (maImage) img.src = maImage;
             }
          }
        });
        */
    }

    // Event Listeners
    speciesFilter.addEventListener('change', () => { currentPage = 1; render(); });
    if (rankFilter) rankFilter.addEventListener('change', () => { currentPage = 1; render(); });
    importantBox.addEventListener('change', () => { currentPage = 1; render(); });
    searchInput.addEventListener('input', debounce(() => { currentPage = 1; render(); }));

    prevBtn.addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        // No need to fetch here, render handles displaying the correct slice
        render();
      }
    });

    nextBtn.addEventListener('click', async () => {
       // Calculate the page index we *will* need data for
       const nextPageNum = currentPage + 1;
       const requiredPageIndex = nextPageNum - 1;

       // Check if we need to load the *next* page's data before incrementing currentPage
       if (!loadedPages.has(requiredPageIndex) && requiredPageIndex < totalPages) {
          await fetchPageIfNeeded(nextPageNum); // Fetch data for the page we are moving to
       }

       // Now, check if we can actually move to the next page based on filtered results
       const filteredListLength = allCharacters.filter(c => { /* apply filters */ return true; }).length; // Re-apply filters quickly to get count
       const filteredTotalPages = Math.max(1, Math.ceil(filteredListLength / PAGE_SIZE));

       if (currentPage < filteredTotalPages) {
          currentPage++;
          render(); // Render the new page
       } else {
          // Optionally disable next button more definitively if already on the last possible filtered page
          nextBtn.disabled = true;
       }
    });

    // Initial Render
    render();
  });
</script>

<style>
  .lcars-character-container {
    position: relative;
    overflow: hidden;
    border-radius: 6px;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  }
  
  .lcars-character-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 0 20px rgba(0, 178, 255, 0.4);
  }
  
  .character-image {
    position: relative;
  }
  
  .character-image img {
    transition: opacity 0.3s ease;
    opacity: 0.2;
  }
  
  .character-image img.loaded {
    opacity: 1;
  }
  
  .character-info {
    border-left: 3px solid var(--starfleet-gold);
    min-height: 80px;
  }
  
  .lcars-select, .lcars-input {
    transition: all 0.3s ease;
  }
  
  .lcars-select:focus, .lcars-input:focus {
    border-color: var(--starfleet-gold);
    outline: none;
    box-shadow: 0 0 10px rgba(0, 178, 255, 0.4);
  }
  
  .species-header {
    position: relative;
    overflow: hidden;
  }
  
  .species-header::after {
    content: '';
    position: absolute;
    left: -100%;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: sweep 3s infinite;
  }
  
  /* Pagination styles */
  .lcars-pagination {
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .lcars-pagination button {
    position: relative;
    z-index: 2;
    transition: all 0.2s ease;
  }
  
  .lcars-pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .lcars-pagination::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 204, 0, 0.1), transparent);
    animation: sweep 2s infinite;
    z-index: 1;
  }
  
  @keyframes sweep {
    0% { left: -100%; }
    100% { left: 100%; }
  }
</style>