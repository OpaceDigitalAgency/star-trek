---
import Layout from '../../layouts/Layout.astro';
import { stapiService, getStaticImage } from '../../services/stapiService';

// Pagination settings
const PAGE_SIZE = 48; // Number of characters to display per page
const currentPage = 1; // Default to first page

// Fetch all characters data from STAPI
let characters = [];
try {
  characters = await stapiService.getAllCharacters();
} catch (error) {
  console.error('Error fetching characters:', error);
}

// Organize characters by species
const charactersBySpecies = new Map();           // Map<string, Character[]>
const seen = new Set();                          // uid dedup for final display

// Process characters for species categorization
characters.forEach(c => {
  // Check for both species and characterSpecies properties
  // STAPI API can return either depending on the endpoint
  let speciesList = [];
  
  // More robust species extraction
  if (c.characterSpecies && Array.isArray(c.characterSpecies) && c.characterSpecies.length > 0) {
    speciesList = c.characterSpecies;
  } else if (c.species && Array.isArray(c.species) && c.species.length > 0) {
    speciesList = c.species;
  } else if (c.characterSpecies === null && c.species === null) {
    // Default to Unknown if both species fields are explicitly null
    speciesList = [{ name: 'Unknown' }];
  } else {
    // Default to Human only if we're sure there's no species data
    speciesList = [{ name: 'Human' }];
  }
  
  
  // If speciesList is empty or contains only null/undefined values, default to Unknown
  if (speciesList.length === 0 || speciesList.every(s => !s || !s.name)) {
    speciesList = [{ name: 'Unknown' }];
  }
  
  speciesList.forEach(s => {
    // Ensure we have a valid species name
    const key = (s && s.name) ? s.name : 'Unknown';
    
    if (!charactersBySpecies.has(key)) {
      charactersBySpecies.set(key, []);
    }
    
    // Only add if we haven't seen this UID before
    if (!seen.has(c.uid)) {
      charactersBySpecies.get(key).push(c);
      seen.add(c.uid);
    }
  });
});

// Sort species names alphabetically, but put "Human" and "Unknown" at the top
const speciesNames = [...charactersBySpecies.keys()].sort((a, b) => {
  if (a === 'Human') return -1;
  if (b === 'Human') return 1;
  if (a === 'Unknown') return -1;
  if (b === 'Unknown') return 1;
  return a.localeCompare(b);
});

// Implement pagination for better performance
// Calculate total number of characters across all species
let totalCharacters = 0;
charactersBySpecies.forEach((chars) => {
  totalCharacters += chars.length;
});

const totalPages = Math.ceil(totalCharacters / PAGE_SIZE);
// Single summary log
console.log(`Found ${speciesNames.length} species, ${totalCharacters} total characters`);

// Enhance character data with Memory Alpha information
// Increase the budget to ensure more images load
const IMAGE_BUDGET = 800;          // increased from 400
let downloaded = 0;

// Process images more efficiently by prioritizing visible characters first
// We'll process a subset of characters from each species rather than all at once
for (const [specie, list] of charactersBySpecies) {
  // Process first 20 characters of each species to ensure good coverage
  const charsToProcess = list.slice(0, 20);
  
  for (const char of charsToProcess) {
    if (downloaded >= IMAGE_BUDGET) break;

    // Expand abbreviated names (e.g. "J. Kirk" â†’ "James T. Kirk")
    const queryName = char.name.match(/^[A-Z]\./) ? char.fullName ?? char.name : char.name;

    try {
      const wiki = await stapiService.getMemoryAlphaContent(queryName);
      if (wiki?.image?.includes('placeholder') || wiki?.image?.endsWith('.svg')) {
        // keep searching, don't count towards budget
      } else if (wiki?.image) {
        char.wikiImage = wiki.image;
        downloaded++;
      }
      
      if (wiki?.wikiUrl) {
        char.wikiUrl = wiki.wikiUrl;
      }
    } catch (error) {
      console.error(`Error fetching wiki content for ${queryName}:`, error);
    }
  }
}


// Fallback data if API fails
if (speciesNames.length === 0) {
  const fallbackCharacters = [
    {
      name: "Captain James T. Kirk",
      species: "Human",
      uid: "kirk",
      image: stapiService.getImageUrl("James T. Kirk", 'character'),
      description: "Captain of the USS Enterprise"
    },
    {
      name: "Captain Jean-Luc Picard",
      species: "Human",
      uid: "picard",
      image: stapiService.getImageUrl("Jean-Luc Picard", 'character'),
      description: "Captain of the USS Enterprise-D and E"
    },
    {
      name: "Captain Benjamin Sisko",
      species: "Human",
      uid: "sisko",
      image: stapiService.getImageUrl("Benjamin Sisko", 'character'),
      description: "Commander of Deep Space Nine"
    },
    {
      name: "Captain Kathryn Janeway",
      species: "Human",
      uid: "janeway",
      image: stapiService.getImageUrl("Kathryn Janeway", 'character'),
      description: "Captain of the USS Voyager"
    },
    {
      name: "Spock",
      species: "Vulcan/Human",
      uid: "spock",
      image: stapiService.getImageUrl("Spock", 'character'),
      description: "Science Officer of the USS Enterprise"
    },
    {
      name: "Worf",
      species: "Klingon",
      uid: "worf",
      image: stapiService.getImageUrl("Worf", 'character'),
      description: "Security Officer"
    }
  ];
  
  // Populate charactersBySpecies with fallback data
  charactersBySpecies.set("Human", fallbackCharacters.filter(c => c.species === "Human"));
  charactersBySpecies.set("Vulcan/Human", fallbackCharacters.filter(c => c.species === "Vulcan/Human"));
  charactersBySpecies.set("Klingon", fallbackCharacters.filter(c => c.species === "Klingon"));
  speciesNames.push("Human", "Vulcan/Human", "Klingon");
}

// Prepare data for filtering
let availableRanks = [];
// Extract unique ranks
characters.forEach(character => {
  if (character.title?.trim() && !availableRanks.includes(character.title)) {
    availableRanks.push(character.title);
  }
});
availableRanks.sort();

// Create JSON-LD schema for characters page
const charactersSchema = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "name": "Star Trek Characters | Complete Guide to Characters in the Star Trek Universe",
  "description": "Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond.",
  "url": "https://star-trek-timelines.netlify.app/characters/",
  "isPartOf": {
    "@type": "WebSite",
    "name": "Star Trek Timelines",
    "url": "https://star-trek-timelines.netlify.app/"
  },
  "about": {
    "@type": "CreativeWorkSeries",
    "name": "Star Trek",
    "description": "Science fiction media franchise created by Gene Roddenberry"
  },
  "hasPart": [...charactersBySpecies.entries()].slice(0, 5).flatMap(([species, chars]) => {
    return chars.slice(0, 5).map(char => ({
      "@type": "Person",
      "name": char.name,
      "url": `https://star-trek-timelines.netlify.app/characters/${char.uid}/`,
      "jobTitle": char.title || "Officer",
      "description": `${species} character from Star Trek`
    }));
  })
};
---

<Layout
  title="Star Trek Characters | Complete Guide to Characters in the Star Trek Universe"
  description="Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond."
  schemaData={charactersSchema}
>
  <script>
    // Pass data directly to the client as a global variable
    window.characterData = {
      species: JSON.parse(`${JSON.stringify(speciesNames)}`),
      characters: JSON.parse(`${JSON.stringify(Object.fromEntries(charactersBySpecies))}`)
    };
  </script>
  
  <div class="container mx-auto px-4 py-12">
    <div class="lcars-header mb-8">
      <div class="lcars-header-content">
        <h1 class="text-3xl">Federation Personnel Database</h1>
      </div>
    </div>
    
    <div class="lcars-panel mb-12">
      <div class="lcars-top-bar flex">
        <div class="w-32 h-8 bg-starfleet-gold rounded-tl-lg"></div>
        <div class="flex-1 h-8 bg-starfleet-blue"></div>
        <div class="w-16 h-8 bg-starfleet-red"></div>
      </div>
      
      <div class="panel-content p-6">
        <p class="text-gray-300 mb-6">
          Accessing Federation personnel records... This database contains information on notable individuals
          from across the Star Trek universe, organized by species and rank. Explore the profiles of Starfleet officers,
          diplomats, scientists, and others who have shaped the history of the galaxy.
        </p>
        
        <div class="filters mb-8">
          <div class="flex flex-wrap gap-4">
            <div class="filter-group">
              <h3 class="text-white text-lg mb-2">Filter by Species</h3>
              <select
                id="species-filter"
                class="appearance-none bg-space-black text-white p-2 pr-8 border border-starfleet-blue rounded relative"
              >
                <option value="all">All Species</option>
                {speciesNames.map(species => (
                  <option value={species}>{species}</option>
                ))}
              </select>
              <!-- chevron -->
              <svg class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 fill-starfleet-gold"
                   viewBox="0 0 20 20"><path d="M5 7l5 5 5-5H5z"/></svg>
            </div>
            
            {availableRanks.length > 0 && (
              <div class="filter-group">
                <h3 class="text-white text-lg mb-2">Filter by Rank</h3>
                <select
                  id="rank-filter"
                  class="appearance-none bg-space-black text-white p-2 pr-8 border border-starfleet-blue rounded relative"
                >
                  <option value="all">All Ranks</option>
                  {availableRanks.map(rank => (
                    <option value={rank}>{rank}</option>
                  ))}
                </select>
                <!-- chevron -->
                <svg class="pointer-events-none absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 fill-starfleet-gold"
                     viewBox="0 0 20 20"><path d="M5 7l5 5 5-5H5z"/></svg>
              </div>
            )}
            
            <div class="filter-group ml-4">
              <h3 class="text-white text-lg mb-2">Show Only</h3>
              <div class="flex items-center">
                <input
                  type="checkbox"
                  id="important-only"
                  class="mr-2"
                >
                <label for="important-only" class="text-white">Important Characters</label>
              </div>
            </div>
            
            <div class="filter-group ml-auto">
              <h3 class="text-white text-lg mb-2">Search</h3>
              <input
                type="text"
                id="search-input"
                placeholder="Search characters..."
                class="appearance-none bg-space-black border border-starfleet-blue text-white p-2 rounded"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Species sections with pagination -->
    <div id="characters-container">
      {speciesNames.map(species => (
        <div class="species-section mb-12" data-species={species}>
          <div class={`species-header bg-starfleet-blue p-3 rounded-lg mb-6 flex items-center`}>
            <div class="w-4 h-4 bg-starfleet-gold rounded-full mr-3"></div>
            <h2 class="text-2xl text-white">{species}</h2>
            <div class="character-count ml-auto px-3 py-1 bg-space-black rounded-full text-white text-sm">
              {charactersBySpecies.get(species)?.length || 0} characters
            </div>
          </div>
          
          <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            {charactersBySpecies.get(species)?.slice(0, PAGE_SIZE).map(character => (
              <div class="character-card" data-rank={character.title} data-important={character.important ? "true" : undefined}>
                <a href={`/characters/${character.uid}/`} class="block">
                  <div class="lcars-character-container">
                    <div class="lcars-side-bar w-3 h-full bg-starfleet-gold absolute left-0 top-0 bottom-0"></div>
                    
                    <div class="character-image aspect-square overflow-hidden">
                      <img
                        width="160" height="160"
                        loading="lazy"
                        src="/images/generic-character.jpg"
                        data-src={character.wikiImage
                          ?? getStaticImage(character.uid)
                          ?? '/images/generic-character.jpg'}
                        alt={character.name}
                        class="w-full h-full object-cover"
                        onerror="this.onerror=null; this.src='/images/generic-character.jpg';"
                      />
                      <div class="character-overlay absolute inset-0 bg-gradient-to-t from-space-black to-transparent opacity-70"></div>
                    </div>
                    
                    <div class="character-info p-4 bg-space-black relative">
                      <h3 class="text-lg text-white font-semibold" data-name>{character.name}</h3>
                      {character.title && (
                        <p class="text-console-blue">{character.title}</p>
                      )}
                      {character.gender && (
                        <div class="character-gender absolute top-4 right-4 px-2 py-1 rounded-full bg-starfleet-blue text-white text-xs">
                          {character.gender}
                        </div>
                      )}
                      
                      {character.wikiUrl && (
                        <a href={character.wikiUrl} target="_blank" rel="noopener noreferrer" class="text-xs text-starfleet-gold hover:underline inline-flex items-center mt-1" onclick="event.stopPropagation()">
                          Memory Alpha <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg>
                        </a>
                      )}
                    </div>
                  </div>
                </a>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
    
    <!-- Pagination controls -->
    <div id="pagination-controls" class="flex justify-center items-center my-8">
      <div class="lcars-pagination flex items-center bg-space-black border border-starfleet-blue rounded-lg overflow-hidden">
        <button id="prev-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
          Previous
        </button>
        <div class="px-4 py-2 text-white">
          Page <span id="current-page-num">1</span> of <span id="total-pages">{totalPages}</span>
        </div>
        <button id="next-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
          Next
        </button>
      </div>
    </div>
    
    <!-- No results message (hidden by default) -->
    <div id="no-results" class="hidden text-center py-8">
      <div class="lcars-panel p-6 inline-block">
        <p class="text-console-blue text-xl">No characters match your search criteria.</p>
        <p class="text-white mt-2">Please adjust your filters or try a different search term.</p>
      </div>
    </div>
  </div>
</Layout>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const speciesFilter = document.getElementById('species-filter');
    const rankFilter = document.getElementById('rank-filter');
    const searchInput = document.getElementById('search-input');
    const importantOnlyCheckbox = document.getElementById('important-only');
    const charactersContainer = document.getElementById('characters-container');
    const noResults = document.getElementById('no-results');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const currentPageDisplay = document.getElementById('current-page-num');
    const totalPagesDisplay = document.getElementById('total-pages');
    
    // Pagination state
    let currentPage = 1;
    const pageSize = 48; // Should match PAGE_SIZE in Astro
    let totalPages = parseInt(totalPagesDisplay.textContent) || 1;
    
    // Get all character data from the global variable
    const allCharactersBySpecies = window.characterData.characters;
    const speciesNames = window.characterData.species;
    const flatCharacters = Object.values(allCharactersBySpecies).flat();
    
    // Filter and pagination functionality
    const filterAndPaginateCharacters = () => {
      const selectedSpecies = speciesFilter.value;
      const selectedRank = rankFilter?.value;
      const searchTerm = searchInput.value.toLowerCase().trim();
      const showImportantOnly = importantOnlyCheckbox.checked;
      
      // Get all species sections
      const speciesSections = document.querySelectorAll('.species-section');
      
      // Track if we have any visible characters
      let visibleCharactersCount = 0;
      let filteredCharacters = [];
      
      // Process each species section
      speciesSections.forEach(section => {
        const sectionSpecies = section.getAttribute('data-species');
        const shouldShowSection = selectedSpecies === 'all' || selectedSpecies === sectionSpecies;
        
        if (!shouldShowSection) {
          section.classList.add('hidden');
          return;
        }
        
        // Get all character cards for this species (from our stored data)
        const allCards = allCharactersBySpecies[sectionSpecies] || [];
        
        // Filter cards based on rank, search, and important flag
        const filteredCards = allCards.filter(card => {
          const cardRank = card.title || '';
          const isImportant = card.important || false;
          const characterName = (card.name || '').toLowerCase();
          
          // More robust search - check if character matches all filters
          const matchesRank = !selectedRank || selectedRank === 'all' || cardRank === selectedRank;
          const matchesImportant = !showImportantOnly || isImportant;
          
          // Improved search matching - handle partial names and common prefixes
          let matchesSearch = false;
          
          if (!searchTerm) {
            // No search term, so it matches
            matchesSearch = true;
          } else if (characterName.includes(searchTerm)) {
            // Direct match
            matchesSearch = true;
          } else {
            // Try expanded titles
            const expandedName = characterName.replace(/\b(lt|cmdr|capt|adm|cmd|dr)\b\./i, match => {
              return {
                'lt.': 'lieutenant',
                'cmdr.': 'commander',
                'capt.': 'captain',
                'adm.': 'admiral',
                'cmd.': 'commander',
                'dr.': 'doctor'
              }[match.toLowerCase()] || match;
            });
            
            if (expandedName.includes(searchTerm)) {
              matchesSearch = true;
            }
          }
          
          return matchesRank && matchesSearch && matchesImportant;
        });
        
        
        // Add to our overall filtered list
        filteredCharacters = filteredCharacters.concat(filteredCards);
        
        // Show/hide section based on whether it has visible characters
        if (filteredCards.length > 0) {
          section.classList.remove('hidden');
          
          // Get the grid container for this section
          const gridContainer = section.querySelector('.grid');
          
          // Clear existing cards
          gridContainer.innerHTML = '';
          
          // Calculate pagination for this section
          const startIdx = (currentPage - 1) * pageSize;
          const endIdx = startIdx + pageSize;
          
          // Add cards for current page
          const cardsToShow = filteredCards.slice(startIdx, endIdx);
          cardsToShow.forEach(card => {
            // Create a new card element
            const cardElement = createCardElement(card, sectionSpecies);
            gridContainer.appendChild(cardElement);
            visibleCharactersCount++;
          });
          
        } else {
          section.classList.add('hidden');
        }
      });
      
      
      // Update pagination
      totalPages = Math.max(1, Math.ceil(filteredCharacters.length / pageSize));
      if (currentPage > totalPages) currentPage = totalPages;
      totalPagesDisplay.textContent = totalPages;
      currentPageDisplay.textContent = currentPage;
      
      // Update pagination button states
      prevPageBtn.disabled = currentPage <= 1;
      nextPageBtn.disabled = currentPage >= totalPages;
      
      // Make pagination controls visible only if we have multiple pages
      const paginationControls = document.getElementById('pagination-controls');
      if (totalPages > 1) {
        paginationControls.classList.remove('hidden');
      } else {
        paginationControls.classList.add('hidden');
      }
      
      // Show/hide no results message
      if (visibleCharactersCount === 0) {
        noResults.classList.remove('hidden');
      } else {
        noResults.classList.add('hidden');
      }
      
      // Reinitialize lazy loading for newly visible images
      initLazyLoading();
    };
    
    // Function to create a card element from character data
    const createCardElement = (character, species) => {
      const cardElement = document.createElement('div');
      cardElement.className = 'character-card';
      if (character.title) {
        cardElement.setAttribute('data-rank', character.title);
      }
      if (character.important) {
        cardElement.setAttribute('data-important', 'true');
      }
      
      cardElement.innerHTML = `
        <a href="/characters/${character.uid}/" class="block">
          <div class="lcars-character-container">
            <div class="lcars-side-bar w-3 h-full bg-starfleet-gold absolute left-0 top-0 bottom-0"></div>
            
            <div class="character-image aspect-square overflow-hidden">
              <img
                width="160" height="160"
                loading="lazy"
                src="/images/generic-character.jpg"
                data-src="${character.wikiImage || '/images/generic-character.jpg'}"
                alt="${character.name}"
                class="w-full h-full object-cover"
                onerror="this.onerror=null; this.src='/images/generic-character.jpg';"
              />
              <div class="character-overlay absolute inset-0 bg-gradient-to-t from-space-black to-transparent opacity-70"></div>
            </div>
            
            <div class="character-info p-4 bg-space-black relative">
              <h3 class="text-lg text-white font-semibold" data-name>${character.name}</h3>
              ${character.title ? `<p class="text-console-blue">${character.title}</p>` : ''}
              ${character.gender ? `
                <div class="character-gender absolute top-4 right-4 px-2 py-1 rounded-full bg-starfleet-blue text-white text-xs">
                  ${character.gender}
                </div>
              ` : ''}
              
              ${character.wikiUrl ? `
                <a href="${character.wikiUrl}" target="_blank" rel="noopener noreferrer" class="text-xs text-starfleet-gold hover:underline inline-flex items-center mt-1" onclick="event.stopPropagation()">
                  Memory Alpha <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></svg>
                </a>
              ` : ''}
            </div>
          </div>
        </a>
      `;
      
      return cardElement;
    };

    // Debounce function to prevent UI flashing
    const debounce = (func, delay) => {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    };
    
    // Pagination event handlers
    prevPageBtn.addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        currentPageDisplay.textContent = currentPage;
        filterAndPaginateCharacters();
        window.scrollTo(0, 0);
      }
    });
    
    nextPageBtn.addEventListener('click', () => {
      if (currentPage < totalPages) {
        currentPage++;
        currentPageDisplay.textContent = currentPage;
        filterAndPaginateCharacters();
        window.scrollTo(0, 0);
      }
    });
    
    // Debounced filter function
    const debouncedFilter = debounce(() => {
      currentPage = 1; // Reset to first page on filter change
      currentPageDisplay.textContent = currentPage;
      filterAndPaginateCharacters();
    }, 250);
    
    // Attach filter event listeners with debounce
    speciesFilter.addEventListener('change', debouncedFilter);
    
    if (rankFilter) {
      rankFilter.addEventListener('change', debouncedFilter);
    }
    
    searchInput.addEventListener('input', debouncedFilter);
    importantOnlyCheckbox.addEventListener('change', debouncedFilter);
    
    // Improved lazy loading function
    const initLazyLoading = () => {
      if (!('IntersectionObserver' in window)) {
        // Fallback for browsers that don't support IntersectionObserver
        document.querySelectorAll('img[data-src]').forEach(img => {
          img.src = img.dataset.src;
          img.removeAttribute('data-src');
        });
        return;
      }
      
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img.dataset.src) {
              // Create a new image to preload
              const tempImg = new Image();
              tempImg.onload = () => {
                img.src = img.dataset.src;
                img.classList.add('loaded');
              };
              tempImg.onerror = () => {
                // If image fails to load, use the error handler already in the HTML
                img.onerror();
              };
              tempImg.src = img.dataset.src;
              img.removeAttribute('data-src');
            }
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '100px', // Start loading when image is 100px from viewport
        threshold: 0.1
      });
      
      document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
      });
    };
    
    // Initialize on page load
    filterAndPaginateCharacters();
    // Initialize lazy loading after cards are rendered
    setTimeout(initLazyLoading, 100);
  });
</script>

<style>
  .lcars-character-container {
    position: relative;
    overflow: hidden;
    border-radius: 6px;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  }
  
  .lcars-character-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 0 20px rgba(0, 178, 255, 0.4);
  }
  
  .character-image {
    position: relative;
  }
  
  .character-image img {
    transition: opacity 0.3s ease;
    opacity: 0.2;
  }
  
  .character-image img.loaded {
    opacity: 1;
  }
  
  .character-info {
    border-left: 3px solid var(--starfleet-gold);
    min-height: 80px;
  }
  
  .lcars-select, .lcars-input {
    transition: all 0.3s ease;
  }
  
  .lcars-select:focus, .lcars-input:focus {
    border-color: var(--starfleet-gold);
    outline: none;
    box-shadow: 0 0 10px rgba(0, 178, 255, 0.4);
  }
  
  .species-header {
    position: relative;
    overflow: hidden;
  }
  
  .species-header::after {
    content: '';
    position: absolute;
    left: -100%;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: sweep 3s infinite;
  }
  
  /* Pagination styles */
  .lcars-pagination {
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .lcars-pagination button {
    position: relative;
    z-index: 2;
    transition: all 0.2s ease;
  }
  
  .lcars-pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .lcars-pagination::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 204, 0, 0.1), transparent);
    animation: sweep 2s infinite;
    z-index: 1;
  }
  
  @keyframes sweep {
    0% { left: -100%; }
    100% { left: 100%; }
  }
</style>