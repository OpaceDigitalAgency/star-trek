---
import Layout from '../../layouts/Layout.astro';
import { stapiService } from '../../services/stapiService';

// Import the local characters data
import charactersLocalJson from '../../data/characters-local.json';

// Pagination settings
const PAGE_SIZE = 48;
const initialCharacters = charactersLocalJson.slice(0, PAGE_SIZE);
const totalPages = Math.ceil(charactersLocalJson.length / PAGE_SIZE);
const totalCharacters = charactersLocalJson.length;

// Get all unique species for the filter dropdown
const allSpecies = Array.from(new Set(
  charactersLocalJson.flatMap(c => [
    ...(c.characterSpecies?.map(s => s.name) || []),
    ...(c.species?.map(s => s.name) || [])
  ])
)).sort((a, b) => {
  if (a === 'Human') return -1;
  if (b === 'Human') return 1;
  if (a === 'Unknown') return -1;
  if (b === 'Unknown') return 1;
  return a.localeCompare(b);
});

console.log(`Initial build: Fetched ${initialCharacters.length} characters. Total characters: ${totalCharacters}, Total pages: ${totalPages}. Found ${allSpecies.length} species.`);

// Extract ranks *only* from the initial page for the build
let initialRanks = [...new Set(initialCharacters
  .map(c => c.title?.trim())
  .filter(Boolean) // Remove empty/null titles
)].sort();


// --- REMOVED Memory Alpha image fetching and complex species grouping from build ---


// Create JSON-LD schema for characters page (using initial data)
const charactersSchema = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "name": "Star Trek Characters | Complete Guide to Characters in the Star Trek Universe",
  "description": "Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond.",
  "url": "https://star-trek-timelines.netlify.app/characters/",
  "isPartOf": {
    "@type": "WebSite",
    "name": "Star Trek Timelines",
    "url": "https://star-trek-timelines.netlify.app/"
  },
  "about": {
    "@type": "CreativeWorkSeries",
    "name": "Star Trek",
    "description": "Science fiction media franchise created by Gene Roddenberry"
  },
  // Update hasPart to use initialCharacters
  "hasPart": initialCharacters.slice(0, 10).map(char => ({ // Limit to first 10 for schema
      "@type": "Person",
      "name": char.name,
      // Ensure slug/uid exists for URL generation
      "url": `https://star-trek-timelines.netlify.app/characters/${char.uid}/`,
      "jobTitle": char.title || "Officer",
      // Try to get species name if available in character object
      "description": `${char.characterSpecies?.[0]?.name || char.species?.[0]?.name || 'Unknown'} character from Star Trek`
  }))
};
---

<Layout
  title="Star Trek Characters | Complete Guide to Characters in the Star Trek Universe"
  description="Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond."
  schemaData={charactersSchema}
>
  
  <div class="container mx-auto px-4 py-12">
    <div class="lcars-header mb-8">
      <div class="lcars-header-content">
        <h1 class="text-3xl">Federation Personnel Database</h1>
      </div>
    </div>
    
    <div class="lcars-panel mb-12">
      <div class="lcars-top-bar flex">
        <div class="w-32 h-8 bg-starfleet-gold rounded-tl-lg"></div>
        <div class="flex-1 h-8 bg-starfleet-blue"></div>
        <div class="w-16 h-8 bg-starfleet-red"></div>
      </div>
      
      <div class="panel-content p-6">
        <p class="text-gray-300 mb-6">
          Accessing Federation personnel records... This database contains information on notable individuals
          from across the Star Trek universe, organized by species and rank. Explore the profiles of Starfleet officers,
          diplomats, scientists, and others who have shaped the history of the galaxy.
        </p>
        
        <div class="filters mb-8">
          <div class="flex flex-wrap gap-4">
            <div class="filter-group relative">
              <h3 class="text-white text-lg mb-2">Filter by Species</h3>
              <div class="relative">
                <select
                  id="species-filter"
                  class="w-48 bg-space-black text-white p-2 border border-starfleet-blue rounded cursor-pointer hover:border-starfleet-gold focus:border-starfleet-gold focus:outline-none"
                >
                  <option value="all">All Species</option>
                  {allSpecies.map(species => (
                    <option value={species}>{species}</option>
                  ))}
                </select>
              </div>
            </div>
            
            {initialRanks.length > 0 && (
                          <div class="filter-group relative">
                            <h3 class="text-white text-lg mb-2">Filter by Rank</h3>
                            <div class="relative">
                              <select
                                id="rank-filter"
                                class="w-48 bg-space-black text-white p-2 border border-starfleet-blue rounded cursor-pointer hover:border-starfleet-gold focus:border-starfleet-gold focus:outline-none"
                              >
                                <option value="all">All Ranks</option>
                                {initialRanks.map(rank => (
                                  <option value={rank}>{rank}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                        )}
            
            <div class="filter-group ml-4">
              <h3 class="text-white text-lg mb-2">Show Only</h3>
              <div class="flex flex-col gap-2">
                <div class="flex items-center">
                  <input
                    type="checkbox"
                    id="important-filter"
                    class="mr-2 w-4 h-4 accent-starfleet-gold cursor-pointer"
                    onclick="this.blur()"
                  >
                  <label for="important-filter" class="text-white cursor-pointer select-none hover:text-starfleet-gold">Important Characters</label>
                </div>
                <div class="flex items-center">
                  <input
                    type="checkbox"
                    id="keep-filter"
                    class="mr-2 w-4 h-4 accent-starfleet-gold cursor-pointer"
                    onclick="this.blur()"
                  >
                  <label for="keep-filter" class="text-white cursor-pointer select-none hover:text-starfleet-gold">Primary Actor Records</label>
                </div>
              </div>
            </div>
            
            <div class="filter-group ml-auto">
              <h3 class="text-white text-lg mb-2">Search</h3>
              <input
                type="text"
                id="search-input"
                placeholder="Search characters..."
                class="appearance-none bg-space-black border border-starfleet-blue text-white p-2 rounded"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Characters container -->
    <div
      id="characters-container"
      class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"
    />
    
    <!-- Pagination controls -->
    <div class="flex justify-between items-center my-8">
      <div class="character-count px-3 py-1 bg-space-black rounded-full text-white text-sm" id="characters-count">
        {totalCharacters} characters
      </div>
      
      <div id="pagination-controls" class="flex justify-center items-center">
        <div class="lcars-pagination flex items-center bg-space-black border border-starfleet-blue rounded-lg overflow-hidden">
          <button id="prev-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Previous
          </button>
          <div class="px-4 py-2 text-white">
            Page <span id="current-page-num">1</span> of <span id="total-pages">{totalPages}</span>
          </div>
          <button id="next-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Next
          </button>
        </div>
      </div>
    </div>
    
    <!-- No results message (hidden by default) -->
    <div id="no-results" class="hidden text-center py-8">
      <div class="lcars-panel p-6 inline-block">
        <p class="text-console-blue text-xl">No characters match your search criteria.</p>
        <p class="text-white mt-2">Please adjust your filters or try a different search term.</p>
      </div>
    </div>
  </div>
</Layout>

<script
  id="initial-payload"
  type="application/json"
  set:html={JSON.stringify({
    characters: charactersLocalJson,
    totalPages: totalPages,
    totalCharacters: totalCharacters,
    pageSize: PAGE_SIZE,
    // Pass initial ranks too, species are already in the dropdown
    initialRanks: initialRanks
  })}
/>

<script>
  // Simple slugify function for client-side use
  function slugify(text) {
    return text
      .toString()
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')        // Replace spaces with -
      .replace(/&/g, '-and-')      // Replace & with 'and'
      .replace(/[^\w\-]+/g, '')    // Remove all non-word characters
      .replace(/\-\-+/g, '-')      // Replace multiple - with single -
      .replace(/^-+/, '')          // Trim - from start of text
      .replace(/-+$/, '');         // Trim - from end of text
  }

  // Client-side STAPI client using the Netlify proxy
  const stapiClient = {
    PROXY_URL: '/api/characters', // Use the proxy endpoint

    async getCharacters(page = 0, pageSize = 48, filters = {}) {
      try {
        // Create a new object without the pageSize property from filters
        const { pageSize: filterPageSize, ...otherFilters } = filters;
        
        const params = new URLSearchParams({
          pageNumber: page.toString(),
          pageSize: pageSize.toString(),
        });

        // Add filter parameters
        for (const [key, value] of Object.entries(otherFilters)) {
          if (value && value !== 'all') { // Only add active filters
            params.append(key, value);
          }
        }

        const url = `${this.PROXY_URL}?${params.toString()}`;
        console.log(`Fetching via proxy: ${url}`); // Log URL

        const response = await fetch(url); // Fetch from the proxy

        if (!response.ok) {
           const errorData = await response.json().catch(() => ({ error: 'Failed to parse error response' }));
           console.error(`Proxy fetch error! Status: ${response.status}`, errorData);
           throw new Error(`HTTP error! status: ${response.status}, details: ${errorData.error || response.statusText}`);
        }

        const data = await response.json();
        console.log(`Received page ${page} (filtered: ${JSON.stringify(filters)}):`, data); // Log received data
        return data; // Should contain { characters: [], page: { totalPages, totalElements } }
      } catch (error) {
        console.error('Error fetching characters via proxy:', error);
        // Return an empty structure on error to prevent crashes
        return { characters: [], page: { totalPages: 1, totalElements: 0 } };
      }
    }
    // Removed getMemoryAlphaImage - image handling simplified
  };


  document.addEventListener('DOMContentLoaded', () => {
      // Get initial data from payload
      const payload = JSON.parse(document.getElementById('initial-payload').textContent);
      const PAGE_SIZE = payload.pageSize;
      let currentPage = 1;
      let allCharacters = []; // Current page's characters
      let filteredCharacters = [...payload.characters]; // All filtered characters
      let totalPages = Math.ceil(filteredCharacters.length / PAGE_SIZE);
      let totalCharacters = filteredCharacters.length;
      let isLoading = false; // Prevent multiple simultaneous fetches
      let currentFilters = {}; // Initialize current filters

      // Initialize with first page
      allCharacters = filteredCharacters.slice(0, PAGE_SIZE);

      // Style fixes for dropdowns
      const dropdowns = document.querySelectorAll('select');
      dropdowns.forEach(dropdown => {
        const wrapper = dropdown.closest('.relative');
        if (wrapper) {
          wrapper.style.zIndex = '20';
        }
      });

    // DOM Elements
    const speciesFilter = document.getElementById('species-filter');
    const rankFilter = document.getElementById('rank-filter'); // Assuming rank filter exists
    const importantBox = document.getElementById('important-filter');
    const keepBox = document.getElementById('keep-filter');
    const searchInput = document.getElementById('search-input');
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const pageNum = document.getElementById('current-page-num');
    const totalNum = document.getElementById('total-pages');
    const countBadge = document.getElementById('characters-count');
    const container = document.getElementById('characters-container');
    const noResults = document.getElementById('no-results');

    const debounce = (fn, ms = 300) => {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    };

    // Add event listeners for filters
    speciesFilter.addEventListener('change', () => {
      applyFiltersAndFetch();
    });

    if (rankFilter) {
      rankFilter.addEventListener('change', () => {
        applyFiltersAndFetch();
      });
    }

    importantBox.addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      console.log('Important characters checkbox changed:', isChecked);
      console.log('Checkbox element:', e.target);
      console.log('Checkbox properties:', {
        id: e.target.id,
        checked: e.target.checked,
        value: e.target.value
      });
      currentFilters = getCurrentFilters();
      // Removed erroneous line
      // Removed erroneous line
      console.log('Current filters before fetch:', currentFilters);
      applyFiltersAndFetch();
    });

    keepBox.addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      console.log('Primary actor records checkbox changed:', isChecked);
      currentFilters = getCurrentFilters();
      console.log('Current filters:', currentFilters);
      applyFiltersAndFetch();
    });

    // Debounced search input handler
    searchInput.addEventListener('input', debounce(() => {
      applyFiltersAndFetch();
    }, 300));

    // --- Species Dropdown Dynamic Update ---
    // Fetch all matching characters (with current filters except species) and update the species dropdown
    function updateSpeciesDropdown() {
      // Get current filters except species
      const filters = getCurrentFilters();
      delete filters.species;

      // Start with all characters
      let chars = [...payload.characters];
      
      // Apply current filters except species
      if (filters.title) {
        chars = chars.filter(c => c.title?.toLowerCase().includes(filters.title.toLowerCase()));
      }
      if (filters.name) {
        chars = chars.filter(c => c.name.toLowerCase().includes(filters.name.toLowerCase()));
      }
      if (filters.important) {
        chars = chars.filter(c => c.isImportant);
      }
      if (filters.keep) {
        chars = chars.filter(c => c.keep);
      }

      console.log(`Found ${chars.length} characters matching current filters (excluding species)`);

      // Build a set of species with at least one matching character
      const speciesSet = new Set();
      for (const c of chars) {
        // Try both characterSpecies and species arrays
        if (Array.isArray(c.characterSpecies) && c.characterSpecies.length > 0) {
          c.characterSpecies.forEach(s => s?.name && speciesSet.add(s.name));
        } else if (Array.isArray(c.species) && c.species.length > 0) {
          c.species.forEach(s => s?.name && speciesSet.add(s.name));
        }
      }
      // Always include "All Species" as the first option
      const sortedSpecies = Array.from(speciesSet).sort((a, b) => {
        if (a === 'Human') return -1;
        if (b === 'Human') return 1;
        if (a === 'Unknown') return -1;
        if (b === 'Unknown') return 1;
        return a.localeCompare(b);
      });

      // Save current selection
      const prevValue = speciesFilter.value;

      // Clear and repopulate the dropdown
      speciesFilter.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'all';
      allOpt.textContent = 'All Species';
      speciesFilter.appendChild(allOpt);
      for (const s of sortedSpecies) {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        speciesFilter.appendChild(opt);
      }

      // Restore previous selection if still present, else default to "all"
      if (prevValue && (prevValue === 'all' || speciesSet.has(prevValue))) {
        speciesFilter.value = prevValue;
      } else {
        speciesFilter.value = 'all';
      }
    }

    // Function to get current filter values from UI elements
    function getCurrentFilters() {
        const filters = {};
        
        // Species filter
        const speciesVal = speciesFilter.value;
        if (speciesVal && speciesVal !== 'all') {
            filters.species = speciesVal;
        }
        
        // Rank filter
        if (rankFilter) {
            const rankVal = rankFilter.value;
            if (rankVal && rankVal !== 'all') {
                filters.title = rankVal;
            }
        }
        
        // Important characters filter
        console.log('Important checkbox state:', {
            element: importantBox,
            checked: importantBox.checked,
            value: importantBox.value
        });
        filters.important = importantBox.checked;
        
        // Primary actor records filter
        console.log('Keep checkbox state:', {
            element: keepBox,
            checked: keepBox.checked,
            value: keepBox.value
        });
        filters.keep = keepBox.checked;
        
        // Search filter
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
            filters.name = searchTerm;
        }

        console.log('Computed filters:', filters);
        return filters;
    }

    // Function to apply filters and get a specific page
    async function fetchPageIfNeeded(pageNumber) { // pageNumber is 1-based for UI
      console.log('fetchPageIfNeeded called with page:', pageNumber, 'type:', typeof pageNumber);
      if (isLoading) {
        console.log('Already loading, ignoring request');
        return;
      }

      try {
        isLoading = true;
        container.style.opacity = '0.5';

        // Ensure pageNumber is a number
        const pageNum = Number(pageNumber);
        console.log('Converted pageNumber to number:', pageNum);
        
        // Get the requested page
        const pageIndex = pageNum - 1;
        const start = pageIndex * PAGE_SIZE;
        const end = start + PAGE_SIZE;
        
        console.log('Fetching page slice:', {
          pageIndex,
          start,
          end,
          totalItems: filteredCharacters.length
        });
        
        // Check if we need to fetch more data from the API
        if (start >= filteredCharacters.length && pageNum <= totalPages) {
          console.log('Need to fetch more data from API for page:', pageNum);
          // This would be implemented in a real app, but for now we'll just use what we have
        }
        
        // Get the characters for this page
        allCharacters = filteredCharacters.slice(start, end);
        currentPage = pageNum; // Store as a number
        
        console.log('Updated page data:', {
          currentPage,
          itemsInCurrentPage: allCharacters.length
        });

        // Update the UI
        render();
        
        // Update pagination buttons
        prevBtn.disabled = pageNum <= 1 || isLoading;
        nextBtn.disabled = pageNum >= Number(totalPages) || isLoading;
      } catch (error) {
        console.error(`Error fetching page ${pageNumber}:`, error);
        container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error loading characters. Please try again.</p>';
      } finally {
        isLoading = false;
        container.style.opacity = '1';
      }
    }

    // Function to apply filters and update state using local data
    async function applyFiltersAndFetch() {
        if (isLoading) return;

        try {
            isLoading = true;
            container.style.opacity = '0.5';
            container.innerHTML = '<p class="text-center text-white col-span-full">Loading...</p>';
            noResults.classList.add('hidden');
            countBadge.textContent = 'Loading...';

            // Get current filters
            currentFilters = getCurrentFilters();
            console.log('Applying filters:', currentFilters);

            // Fetch characters from the API with filters
            const pageNumber = 1; // Always start with page 1 when applying filters
            const pageSize = PAGE_SIZE;
            const apiFilters = {
                page: pageNumber - 1, // API expects 0-based index
                ...currentFilters,
            };

            // Rename filter parameters to match API expectations
            if (apiFilters.title) {
                apiFilters.rank = apiFilters.title;
                delete apiFilters.title;
            }

            // Convert boolean values to strings for the API
            if (apiFilters.important === true) {
                apiFilters.important = 'true';
            }
            if (apiFilters.keep === true) {
                apiFilters.keep = 'true';
            }

            console.log('Sending API filters:', apiFilters);
            const apiData = await stapiClient.getCharacters(apiFilters.page, pageSize, apiFilters);
            console.log('API data received:', apiData);

            // Update filtered characters and total pages
            filteredCharacters = apiData.characters || [];
            totalCharacters = apiData.page?.totalElements || 0;
            totalPages = Math.ceil(totalCharacters / pageSize);

            // Update the total pages display
            totalNum.textContent = totalPages;

            // Update the character count badge
            countBadge.textContent = `${totalCharacters} characters`;

            // Reset to page 1
            currentPage = 1;
            pageNum.textContent = currentPage;

            // Get the first page of characters
            allCharacters = filteredCharacters.slice(0, PAGE_SIZE);

            // Show no results message if needed
            if (totalCharacters === 0) {
                noResults.classList.remove('hidden');
                container.classList.add('hidden');
                countBadge.textContent = 'No characters found';
            } else {
                noResults.classList.add('hidden');
                container.classList.remove('hidden');
                countBadge.textContent = `${totalCharacters} characters found`;
            }

            // Update species dropdown if needed
            if (!currentFilters.species) {
                updateSpeciesDropdown();
            }

            render();
        } catch (error) {
            console.error('Error applying filters:', error);
            container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error filtering characters. Please try again.</p>';
        } finally {
            isLoading = false;
            container.style.opacity = '1';
        }
    }


    // Function to render the current page based only on the current page's data in `allCharacters`
    function render() {
      try {
        console.log("Render called - current page:", currentPage, "total pages:", totalPages, "total characters:", totalCharacters);
        
        // Update total count display based on the overall total for the current filter set
        countBadge.textContent = `${totalCharacters} characters found`;

        // Update pagination display (uses overall totalPages for the current filter set)
        pageNum.textContent = currentPage;
        totalNum.textContent = totalPages; // Display the overall total pages

        // Enable/disable pagination buttons based on overall totalPages
        const currentPageNum = Number(currentPage);
        const totalPagesNum = Number(totalPages);
        
        // Force update button states immediately and after a short delay
        const updateButtonStates = () => {
          prevBtn.disabled = currentPageNum <= 1 || isLoading;
          nextBtn.disabled = currentPageNum >= totalPagesNum || isLoading;
          
          console.log('Pagination button states:', {
            prevDisabled: prevBtn.disabled,
            nextDisabled: nextBtn.disabled,
            currentPage: currentPageNum,
            totalPages: totalPagesNum,
            isLoading
          });
        };
        
        // Update immediately
        updateButtonStates();
        
        // And again after a short delay to ensure DOM updates
        setTimeout(updateButtonStates, 100);

        // Display "No Results" message if totalCharacters is 0 after fetch/filter
        noResults.classList.toggle('hidden', totalCharacters > 0);
        container.classList.toggle('hidden', totalCharacters === 0); // Hide grid if no results

        // Render character cards for the current page's items (allCharacters is always current page)
        if (totalCharacters > 0) {
            try {
                console.log("Rendering characters:", allCharacters.length);
                
                container.innerHTML = allCharacters.map(c => {
                  if (!c || !c.name) {
                      console.error("Invalid character data:", c);
                      return ''; // Skip invalid characters
                  }
                  
                  // Try to use local cached image first, then wikiImage, then imageUrl, then fallback to generic
                  const imageUrl = c.wikiImage || c.imageUrl || '/images/generic-character.jpg';
                  
                  // Create a slug that includes both the character name and UID
                  // Debug logging for slugify and character fields
                  if (typeof slugify === 'undefined') {
                    console.error("slugify is undefined in client-side render. This will cause a runtime error.");
                  } else {
                    console.log("slugify is defined:", slugify);
                  }
                  if (!c.uid) {
                    console.error("Character missing uid:", c);
                  }
                  if (!c.name) {
                    console.error("Character missing name:", c);
                  }
                  const nameSlug = c.name ? (typeof slugify !== 'undefined' ? slugify(c.name) : 'unknown') : 'unknown';
                  const slug = c.uid ? `${nameSlug}-${c.uid}` : nameSlug; // Combine name slug and UID

             return `
               <div class="character-card bg-space-black border border-starfleet-blue rounded-lg overflow-hidden transition-transform hover:scale-105">
                 <a href="/characters/${slug}/" class="block">
                   <div class="character-image aspect-square bg-gray-800">
                     <img
                       src="${imageUrl}"
                       alt="${c.name}"
                       class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"
                       onerror="this.onerror=null; this.src='/images/generic-character.jpg';"
                     />
                   </div>
                   <div class="character-info p-3 border-t border-starfleet-blue">
                     <h3 class="text-white font-semibold truncate" title="${c.name}">${c.name}</h3>
                     <p class="text-gray-400 text-sm">${c.characterSpecies?.[0]?.name || c.species?.[0]?.name || 'Unknown'}</p>
                   </div>
                 </a>
               </div>
             `;
            }).join('');
          } catch (error) {
            console.error("Error in render function:", error);
            container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error rendering characters. Please check the console for details.</p>';
          }
        } else if (!isLoading) {
            // Ensure loading message is removed if there are truly no results
            container.innerHTML = '';
        }
        // Removed Memory Alpha image fetching logic
      } catch (error) {
        console.error("Error in main render function:", error);
        container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error rendering page. Please check the console for details.</p>';
      }
    }

    // Debounced version of applying filters for search input
    const debouncedApplyFilters = debounce(applyFiltersAndFetch, 500);

    // Event Listeners - Trigger filter application
    speciesFilter.addEventListener('change', applyFiltersAndFetch);
    if (rankFilter) rankFilter.addEventListener('change', applyFiltersAndFetch);
    importantBox.addEventListener('change', applyFiltersAndFetch);
    keepBox.addEventListener('change', applyFiltersAndFetch);
    searchInput.addEventListener('input', debouncedApplyFilters); // Use debounced version for search

    // On initial load, update the species dropdown to match the initial filter state
    updateSpeciesDropdown();

    prevBtn.addEventListener('click', async () => {
      console.log('Previous button clicked', {
        currentPage,
        isLoading,
        disabled: prevBtn.disabled
      });
      
      if (Number(currentPage) > 1 && !isLoading) {
        try {
          const prevPage = Number(currentPage) - 1;
          console.log('Fetching previous page:', prevPage);
          await fetchPageIfNeeded(prevPage);
        } catch (error) {
          console.error('Error navigating to previous page:', error);
        }
      } else {
        console.log('Previous button condition not met', {
          currentPageCheck: Number(currentPage) > 1,
          loadingCheck: !isLoading
        });
      }
    });

    nextBtn.addEventListener('click', function() {
      // Convert to numbers for comparison
      const currentPageNum = Number(currentPage);
      const totalPagesNum = Number(totalPages);
      
      console.log('Next button clicked', {
        currentPage: currentPageNum,
        totalPages: totalPagesNum,
        isLoading,
        disabled: nextBtn.disabled,
        condition: currentPageNum < totalPagesNum
      });
      
      if (currentPageNum < totalPagesNum && !isLoading) {
        try {
          // Use the next page number
          const nextPage = currentPageNum + 1;
          console.log('Fetching next page:', nextPage);
          
          // Call fetchPageIfNeeded with the next page number
          // Use a timeout to ensure the UI updates before fetching the next page
          setTimeout(() => {
            fetchPageIfNeeded(nextPage);
          }, 100);
        } catch (error) {
          console.error('Error navigating to next page:', error);
        }
      } else {
        console.log('Next button condition not met', {
          currentPageCheck: currentPageNum < totalPagesNum,
          loadingCheck: !isLoading
        });
      }
    });

    // Initial Render on Load
    render(); // Render the initial data passed from the server
  });
</script>

<!-- No longer needed since we're using standard img tag -->

<style>
  .lcars-character-container {
    position: relative;
    overflow: hidden;
    border-radius: 6px;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  }
  
  .lcars-character-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 0 20px rgba(0, 178, 255, 0.4);
  }
  
  .character-image {
    position: relative;
  }
  
  .character-image img {
    transition: opacity 0.3s ease;
    opacity: 0.2;
  }
  
  .character-image img.loaded {
    opacity: 1;
  }
  
  .character-info {
    border-left: 3px solid var(--starfleet-gold);
    min-height: 80px;
  }
  
  .lcars-select, .lcars-input {
    transition: all 0.3s ease;
  }
  
  .lcars-select:focus, .lcars-input:focus {
    border-color: var(--starfleet-gold);
    outline: none;
    box-shadow: 0 0 10px rgba(0, 178, 255, 0.4);
  }
  
  .species-header {
    position: relative;
    overflow: hidden;
  }
  
  .species-header::after {
    content: '';
    position: absolute;
    left: -100%;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: sweep 3s infinite;
  }
  
  /* Pagination styles */
  .lcars-pagination {
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .lcars-pagination button {
    position: relative;
    z-index: 2;
    transition: all 0.2s ease;
  }
  
  .lcars-pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .lcars-pagination::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 204, 0, 0.1), transparent);
    animation: sweep 2s infinite;
    z-index: 1;
  }
  
  @keyframes sweep {
    0% { left: -100%; }
    100% { left: 100%; }
  }
</style>