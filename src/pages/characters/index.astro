---
import Layout from '../../layouts/Layout.astro';
import { CHARACTER_PAGE_SIZE } from '../../data/constants.js';
import charactersData from '../../data/characters-local.json';

// Get initial data for first page
const initialCharacters = charactersData.slice(0, CHARACTER_PAGE_SIZE);
const totalCharacters = charactersData.length;
const totalPages = Math.ceil(totalCharacters / CHARACTER_PAGE_SIZE);

// Initial state for client-side
const initialState = {
  characters: initialCharacters,
  totalCharacters,
  totalPages,
  pageSize: CHARACTER_PAGE_SIZE
};

export const prerender = true;
// Get unique species from initial characters
const allSpecies = [
  'Human',
  'Vulcan',
  'Klingon',
  'Romulan',
  'Cardassian',
  'Bajoran',
  'Ferengi',
  'Andorian',
  'Betazoid',
  'Trill',
  'Borg',
  'Changeling',
  'El-Aurian',
  'Tellarite',
  'Unknown'
].sort((a, b) => {
  if (a === 'Human') return -1;
  if (b === 'Human') return 1;
  if (a === 'Unknown') return -1;
  if (b === 'Unknown') return 1;
  return a.localeCompare(b);
});

console.log(`Initial build: Fetched ${initialCharacters.length} characters. Total characters: ${totalCharacters}, Total pages: ${totalPages}. Found ${allSpecies.length} species.`);

// Initialize ranks - will be populated dynamically
let initialRanks = [];

// Function to update ranks dropdown
async function updateRanksDropdown() {
  try {
    // Fetch all characters to get ranks list
    const response = await fetch('/api/characters?pageSize=10000');
    const data = await response.json();
    const allCharacters = data.characters;

    // Extract unique ranks/titles
    const ranksSet = new Set();
    allCharacters.forEach(char => {
      if (char.title?.trim()) {
        ranksSet.add(char.title.trim());
      }
    });

    // Update ranks list
    initialRanks = Array.from(ranksSet).sort();

    // Update dropdown
    if (rankFilter) {
      rankFilter.innerHTML = '<option value="all">All Ranks</option>';
      initialRanks.forEach(rank => {
        const opt = document.createElement('option');
        opt.value = rank;
        opt.textContent = rank;
        rankFilter.appendChild(opt);
      });
    }
  } catch (error) {
    console.error('Error updating ranks dropdown:', error);
  }
}


// --- REMOVED Memory Alpha image fetching and complex species grouping from build ---


// Create JSON-LD schema for characters page (using static data)
const charactersSchema = {
  "@context": "https://schema.org",
  "@type": "CollectionPage",
  "name": "Star Trek Characters | Complete Guide to Characters in the Star Trek Universe",
  "description": "Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond.",
  "url": "https://star-trek-timelines.netlify.app/characters/",
  "isPartOf": {
    "@type": "WebSite",
    "name": "Star Trek Timelines",
    "url": "https://star-trek-timelines.netlify.app/"
  },
  "about": {
    "@type": "CreativeWorkSeries",
    "name": "Star Trek",
    "description": "Science fiction media franchise created by Gene Roddenberry"
  },
  // Use initial characters for schema
  "hasPart": initialCharacters.slice(0, 10).map(char => ({ // Limit to first 10 for schema
      "@type": "Person",
      "name": char.name,
      // Ensure slug/uid exists for URL generation
      "url": `https://star-trek-timelines.netlify.app/characters/${char.uid}/`,
      "jobTitle": char.title || "Officer",
      // Try to get species name if available in character object
      "description": `${char.characterSpecies?.[0]?.name || char.species?.[0]?.name || 'Unknown'} character from Star Trek`
  }))
};
---

<Layout
  title="Star Trek Characters | Complete Guide to Characters in the Star Trek Universe"
  description="Explore the diverse characters of Star Trek from all series and movies. Learn about captains, officers, aliens, and more from across the Federation and beyond."
  schemaData={charactersSchema}
>
  
  <div class="container mx-auto px-4 py-12">
    <div class="lcars-header mb-8">
      <div class="lcars-header-content">
        <h1 class="text-3xl">Federation Personnel Database</h1>
      </div>
    </div>
    
    <div class="lcars-panel mb-12">
      <div class="lcars-top-bar flex">
        <div class="w-32 h-8 bg-starfleet-gold rounded-tl-lg"></div>
        <div class="flex-1 h-8 bg-starfleet-blue"></div>
        <div class="w-16 h-8 bg-starfleet-red"></div>
      </div>
      
      <div class="panel-content p-6">
        <p class="text-gray-300 mb-6">
          Accessing Federation personnel records... This database contains information on notable individuals
          from across the Star Trek universe, organized by species and rank. Explore the profiles of Starfleet officers,
          diplomats, scientists, and others who have shaped the history of the galaxy.
        </p>
        
        <div class="filters mb-8">
          <div class="flex flex-wrap gap-4">
            <div class="filter-group relative">
              <h3 class="text-white text-lg mb-2">Filter by Species</h3>
              <div class="relative">
                <select
                  id="species-filter"
                  class="w-48 bg-space-black text-white p-2 border border-starfleet-blue rounded cursor-pointer hover:border-starfleet-gold focus:border-starfleet-gold focus:outline-none"
                >
                  <option value="all">All Species</option>
                  {allSpecies.map(species => (
                    <option value={species}>{species}</option>
                  ))}
                </select>
              </div>
            </div>
            
            {initialRanks?.length > 0 && (
              <div class="filter-group relative">
                <h3 class="text-white text-lg mb-2">Filter by Rank</h3>
                <div class="relative">
                  <select
                    id="rank-filter"
                    class="w-48 bg-space-black text-white p-2 border border-starfleet-blue rounded cursor-pointer hover:border-starfleet-gold focus:border-starfleet-gold focus:outline-none"
                  >
                    <option value="all">All Ranks</option>
                    {initialRanks.map(rank => (
                      <option value={rank}>{rank}</option>
                    ))}
                  </select>
                </div>
              </div>
            )}
            
            <div class="filter-group ml-4">
              <h3 class="text-white text-lg mb-2">Show Only</h3>
              <div class="flex flex-col gap-2">
                <div class="flex items-center">
                  <input
                    type="checkbox"
                    id="important-filter"
                    class="mr-2 w-4 h-4 accent-starfleet-gold cursor-pointer"
                    onclick="this.blur()"
                  >
                  <label for="important-filter" class="text-white cursor-pointer select-none hover:text-starfleet-gold">Important Characters</label>
                </div>
                <div class="flex items-center">
                  <input
                    type="checkbox"
                    id="keep-filter"
                    class="mr-2 w-4 h-4 accent-starfleet-gold cursor-pointer"
                    onclick="this.blur()"
                  >
                  <label for="keep-filter" class="text-white cursor-pointer select-none hover:text-starfleet-gold">Primary Actor Records</label>
                </div>
              </div>
            </div>
            
            <div class="filter-group ml-auto">
              <h3 class="text-white text-lg mb-2">Search</h3>
              <input
                type="text"
                id="search-input"
                placeholder="Search characters..."
                class="appearance-none bg-space-black border border-starfleet-blue text-white p-2 rounded"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Characters container -->
    <div
      id="characters-container"
      class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"
    />
    
    <!-- Pagination controls -->
    <div class="flex justify-between items-center my-8">
      <div class="character-count px-3 py-1 bg-space-black rounded-full text-white text-sm" id="characters-count">
        {totalCharacters} characters
      </div>
      
      <div id="pagination-controls" class="flex justify-center items-center">
        <div class="lcars-pagination flex items-center bg-space-black border border-starfleet-blue rounded-lg overflow-hidden">
          <button id="prev-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Previous
          </button>
          <div class="px-4 py-2 text-white">
            Page <span id="current-page-num">1</span> of <span id="total-pages">{totalPages}</span>
          </div>
          <button id="next-page" class="px-4 py-2 bg-starfleet-blue text-white hover:bg-starfleet-gold hover:text-space-black transition-colors">
            Next
          </button>
        </div>
      </div>
    </div>
    
    <!-- No results message (hidden by default) -->
    <div id="no-results" class="hidden text-center py-8">
      <div class="lcars-panel p-6 inline-block">
        <p class="text-console-blue text-xl">No characters match your search criteria.</p>
        <p class="text-white mt-2">Please adjust your filters or try a different search term.</p>
      </div>
    </div>
  </div>
</Layout>

<script
  id="initial-payload"
  type="application/json"
  set:html={JSON.stringify(initialState)}
/>

<script>
  // Simple slugify function for client-side use
  function slugify(text) {
    return text
      .toString()
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')        // Replace spaces with -
      .replace(/&/g, '-and-')      // Replace & with 'and'
      .replace(/[^\w\-]+/g, '')    // Remove all non-word characters
      .replace(/\-\-+/g, '-')      // Replace multiple - with single -
      .replace(/^-+/, '')          // Trim - from start of text
      .replace(/-+$/, '');         // Trim - from end of text
  }

  // Load characters from local JSON file
  async function loadCharacters(page = 1, filters = {}) {
    try {
      const response = await fetch('/api/characters', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const allCharacters = await response.json();
      
      // Apply filters
      let filtered = allCharacters;
      
      if (filters.species && filters.species !== 'all') {
        filtered = filtered.filter(char =>
          char.characterSpecies?.some(s => s.name === filters.species) ||
          char.species?.some(s => s.name === filters.species)
        );
      }
      
      if (filters.title && filters.title !== 'all') {
        filtered = filtered.filter(char => char.title === filters.title);
      }
      
      if (filters.important) {
        filtered = filtered.filter(char => char.important || char.isImportant);
      }
      
      if (filters.keep) {
        filtered = filtered.filter(char => char.keep === true);
      }
      
      if (filters.name) {
        const searchTerm = filters.name.toLowerCase();
        filtered = filtered.filter(char =>
          char.name.toLowerCase().includes(searchTerm)
        );
      }

      // Calculate pagination
      const pageSize = 48;
      const start = (page - 1) * pageSize;
      const end = start + pageSize;
      const pageData = filtered.slice(start, end);

      return {
        characters: pageData,
        page: {
          totalPages: Math.ceil(filtered.length / pageSize),
          totalElements: filtered.length,
          pageNumber: page - 1,
          pageSize: pageSize
        }
      };
    } catch (error) {
      console.error('Error loading characters:', error);
      return {
        characters: [],
        page: {
          totalPages: 1,
          totalElements: 0,
          pageNumber: 0,
          pageSize: 48
        }
      };
    }
  }


  document.addEventListener('DOMContentLoaded', () => {
      // Get initial data from payload
      const payload = JSON.parse(document.getElementById('initial-payload').textContent);
      const PAGE_SIZE = payload.pageSize;
      // Initialize state
      let isLoading = false; // Prevent multiple simultaneous fetches
      let currentPage = 1;
      let totalPages = initialState.totalPages;
      let totalCharacters = initialState.totalCharacters;
      let currentFilters = {}; // Initialize current filters

      // Function to render character cards
      function renderCharacters(characters) {
        container.innerHTML = characters.map(char => `
          <div class="character-card group relative bg-space-black border border-starfleet-blue rounded-lg overflow-hidden hover:border-starfleet-gold transition-colors">
            <a href="/characters/${char.uid}/" class="block">
              <div class="aspect-square overflow-hidden">
                <img
                  src="${char.wikiImage || char.image || '/images/generic-character.jpg'}"
                  alt="${char.name}"
                  class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"
                  onerror="this.onerror=null; this.src='/images/generic-character.jpg';"
                />
              </div>
              <div class="p-4">
                <h3 class="text-lg font-semibold text-white mb-1">${char.name}</h3>
                ${char.title ? `<p class="text-starfleet-gold text-sm">${char.title}</p>` : ''}
                ${char.characterSpecies?.length ?
                  `<p class="text-gray-400 text-sm">${char.characterSpecies.map(s => s.name).join(', ')}</p>` :
                  (char.species?.length ?
                    `<p class="text-gray-400 text-sm">${char.species.map(s => s.name).join(', ')}</p>` :
                    '')}
              </div>
            </a>
          </div>
        `).join('');
      }

      // Initial render
      renderCharacters(initialState.characters);

      // Style fixes for dropdowns
      const dropdowns = document.querySelectorAll('select');
      dropdowns.forEach(dropdown => {
        const wrapper = dropdown.closest('.relative');
        if (wrapper) {
          wrapper.style.zIndex = '20';
        }
      });

    // DOM Elements
    const speciesFilter = document.getElementById('species-filter');
    const rankFilter = document.getElementById('rank-filter'); // Assuming rank filter exists
    const importantBox = document.getElementById('important-filter');
    const keepBox = document.getElementById('keep-filter');
    const searchInput = document.getElementById('search-input');
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const pageNum = document.getElementById('current-page-num');
    const totalNum = document.getElementById('total-pages');
    const countBadge = document.getElementById('characters-count');
    const container = document.getElementById('characters-container');
    const noResults = document.getElementById('no-results');

    const debounce = (fn, ms = 300) => {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
      };
    };

    // Add event listeners for filters
    speciesFilter.addEventListener('change', () => {
      console.log('Species filter changed');
      applyFiltersAndFetch();
    });

    if (rankFilter) {
      rankFilter.addEventListener('change', () => {
        console.log('Rank filter changed');
        applyFiltersAndFetch();
      });
    }


    // Multiple event handlers for checkboxes to ensure they trigger
    const handleImportantChange = (e) => {
      const isChecked = e.target.checked;
      console.log('Important characters checkbox changed:', isChecked);
      // Force update the currentFilters
      currentFilters.important = isChecked;
      console.log('Current filters after important update:', currentFilters);
      applyFiltersAndFetch();
    };

    const handleKeepChange = (e) => {
      const isChecked = e.target.checked;
      console.log('Primary actor records checkbox changed:', isChecked);
      // Force update the currentFilters
      currentFilters.keep = isChecked;
      console.log('Current filters after keep update:', currentFilters);
      applyFiltersAndFetch();
    };

    // Add both click and change event listeners to ensure they trigger
    importantBox.addEventListener('click', handleImportantChange);
    importantBox.addEventListener('change', handleImportantChange);
    
    keepBox.addEventListener('click', handleKeepChange);
    keepBox.addEventListener('change', handleKeepChange);

    // Debounced search input handler
    searchInput.addEventListener('input', debounce(() => {
      console.log('Search input changed');
      currentPage = 1; // Reset to first page on search
      applyFiltersAndFetch();
    }, 300));

    // Update UI elements with pagination state
    function updatePaginationUI() {
      pageNum.textContent = currentPage;
      totalNum.textContent = totalPages;
      prevBtn.disabled = currentPage <= 1 || isLoading;
      nextBtn.disabled = currentPage >= totalPages || isLoading;
      countBadge.textContent = `${totalCharacters} characters`;
    }

    // --- Species Dropdown Dynamic Update ---
    // Fetch all matching characters (with current filters except species) and update the species dropdown
    async function updateSpeciesDropdown() {
      try {
        // Fetch all characters to get species list
        const response = await fetch('/api/characters?pageSize=10000');
        const data = await response.json();
        const allCharacters = data.characters;

        // Extract unique species from characters
        const speciesSet = new Set();
        allCharacters.forEach(char => {
          if (char.characterSpecies) {
            char.characterSpecies.forEach(s => s.name && speciesSet.add(s.name));
          }
          if (char.species) {
            char.species.forEach(s => s.name && speciesSet.add(s.name));
          }
        });

        // Convert to sorted array
        const sortedSpecies = Array.from(speciesSet).sort((a, b) => {
          if (a === 'Human') return -1;
          if (b === 'Human') return 1;
          if (a === 'Unknown') return -1;
          if (b === 'Unknown') return 1;
          return a.localeCompare(b);
        });

      // Save current selection
      const prevValue = speciesFilter.value;

      // Clear and repopulate the dropdown
      speciesFilter.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'all';
      allOpt.textContent = 'All Species';
      speciesFilter.appendChild(allOpt);
      for (const s of sortedSpecies) {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        speciesFilter.appendChild(opt);
      }

      // Restore previous selection if still present, else default to "all"
      if (prevValue && (prevValue === 'all' || speciesSet.has(prevValue))) {
        speciesFilter.value = prevValue;
      } else {
        speciesFilter.value = 'all';
      }
    }

    // Add pagination event handlers
    prevBtn.addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        fetchPageIfNeeded(currentPage);
      }
    });

    nextBtn.addEventListener('click', () => {
      if (currentPage < totalPages) {
        currentPage++;
        fetchPageIfNeeded(currentPage);
      }
    });

    // Function to get current filter values
    function getCurrentFilters() {
      return {
        species: speciesFilter?.value !== 'all' ? speciesFilter?.value : undefined,
        title: rankFilter?.value !== 'all' ? rankFilter?.value : undefined,
        important: importantBox?.checked,
        keep: keepBox?.checked,
        name: searchInput?.value?.trim() || undefined
      };
    }

    // Function to apply filters and fetch results
    async function applyFiltersAndFetch() {
      currentPage = 1; // Reset to first page when filters change
      currentFilters = getCurrentFilters();
      await fetchPageIfNeeded(currentPage);
    }

    // Initial load
    async function initialize() {
      try {
        // Show loading state
        isLoading = true;
        container.style.opacity = '0.5';

        // Update dropdowns first
        await Promise.all([
          updateSpeciesDropdown(),
          updateRanksDropdown()
        ]);
        
        // Then fetch first page of characters
        await fetchPageIfNeeded(1);

        // Update UI
        updatePaginationUI();
      } catch (error) {
        console.error('Error during initialization:', error);
        container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error loading characters. Please try again.</p>';
      } finally {
        isLoading = false;
        container.style.opacity = '1';
      }
    }

    // Start initialization
    initialize();
    // Function to get current filter values from UI elements
    function getCurrentFilters() {
        const filters = {};
        
        // Species filter
        const speciesVal = speciesFilter.value;
        if (speciesVal && speciesVal !== 'all') {
            filters.species = speciesVal;
        }
        
        // Rank filter
        if (rankFilter) {
            const rankVal = rankFilter.value;
            if (rankVal && rankVal !== 'all') {
                filters.title = rankVal;
            }
        }
        
        // Important characters filter
        console.log('Important checkbox state:', {
            element: importantBox,
            checked: importantBox.checked,
            value: importantBox.value
        });
        filters.important = importantBox.checked;
        
        // Primary actor records filter
        console.log('Keep checkbox state:', {
            element: keepBox,
            checked: keepBox.checked,
            value: keepBox.value
        });
        filters.keep = keepBox.checked;
        
        // Search filter
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
            filters.name = searchTerm;
        }

        console.log('Computed filters:', filters);
        return filters;
    }

    // Function to apply filters and get a specific page
    async function fetchPageIfNeeded(pageNumber) {
      if (isLoading) return;

      try {
        isLoading = true;
        container.style.opacity = '0.5';

        // Get current filters
        const filters = getCurrentFilters();
        
        // Load filtered characters
        const result = await loadCharacters(pageNumber, filters);
        
        // Update state
        currentPage = pageNumber;
        totalPages = result.page.totalPages;
        totalCharacters = result.page.totalElements;
        
        // Update UI
        renderCharacters(result.characters);
        updatePaginationUI();
        
        // Show/hide no results message
        if (result.characters.length === 0) {
          container.classList.add('hidden');
          noResults.classList.remove('hidden');
        } else {
          container.classList.remove('hidden');
          noResults.classList.add('hidden');
        }

        // Update character count
        countBadge.textContent = `${result.page.totalElements} characters found`;
        };
        
        // Rename filter parameters to match API expectations
        if (apiFilters.title) {
          apiFilters.rank = apiFilters.title;
          delete apiFilters.title;
        }
        
        // Convert boolean values to strings for the API
        if (apiFilters.important === true) {
          apiFilters.important = 'true';
        }
        if (apiFilters.keep === true) {
          apiFilters.keep = 'true';
        }
        
        console.log('Sending API filters for page:', apiFilters);
        const apiData = await stapiClient.getCharacters(apiPageNumber, pageSize, apiFilters);
        
        // Update state with new data
        allCharacters = apiData.characters || [];
        currentPage = pageNumber; // Keep UI page number as 1-based
        totalPages = apiData.page?.totalPages || Math.ceil(totalCharacters / pageSize);
        totalCharacters = apiData.page?.totalElements || totalCharacters;
        
        console.log('Updated page data:', {
          currentPage,
          itemsInCurrentPage: allCharacters.length,
          totalPages,
          totalCharacters
        });

        // Update the UI
        render();
        
        // Update pagination buttons (adjust for 1-based UI pagination)
        prevBtn.disabled = currentPage <= 1 || isLoading;
        nextBtn.disabled = currentPage >= totalPages || isLoading;

        // Update page number display
        pageNum.textContent = currentPage;
        totalNum.textContent = totalPages;
      } catch (error) {
        console.error(`Error fetching page ${pageNumber}:`, error);
        container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error loading characters. Please try again.</p>';
      } finally {
        isLoading = false;
        container.style.opacity = '1';
      }
    }

    // Function to apply filters and update state using local data
    async function applyFiltersAndFetch() {
        if (isLoading) return;

        try {
            isLoading = true;
            container.style.opacity = '0.5';
            container.innerHTML = '<p class="text-center text-white col-span-full">Loading...</p>';
            noResults.classList.add('hidden');
            countBadge.textContent = 'Loading...';

            // Get current filters from UI elements directly
            const filters = {
                species: speciesFilter.value !== 'all' ? speciesFilter.value : undefined,
                important: importantBox.checked,
                keep: keepBox.checked
            };
            
            // Add rank filter if available
            if (rankFilter && rankFilter.value !== 'all') {
                filters.title = rankFilter.value;
            }
            
            // Add search term if available
            const searchTerm = searchInput.value.trim();
            if (searchTerm) {
                filters.name = searchTerm;
            }
            
            // Update current filters
            currentFilters = filters;
            console.log('Applying filters (direct from UI):', currentFilters);

            // Fetch characters from the API with filters
            // Convert UI page number (1-based) to API page number (0-based)
            const apiPageNumber = 0; // Always start at first page when applying filters
            const pageSize = PAGE_SIZE;
            const apiFilters = {
                ...currentFilters,
                page: apiPageNumber
            };
            
            // Reset pagination state
            currentPage = 1;

            // Rename filter parameters to match API expectations
            if (apiFilters.title) {
                apiFilters.rank = apiFilters.title;
                delete apiFilters.title;
            }

            // Convert boolean values to strings for the API
            apiFilters.important = apiFilters.important ? 'true' : 'false';
            apiFilters.keep = apiFilters.keep ? 'true' : 'false';

            console.log('Sending API filters:', apiFilters);
            const apiData = await stapiClient.getCharacters(apiPageNumber, pageSize, apiFilters);
            console.log('API data received:', apiData);

            // Update filtered characters and total pages
            // We only get the first page of filtered characters here
            // The rest will be fetched as needed by fetchPageIfNeeded
            filteredCharacters = apiData.characters || [];
            totalCharacters = apiData.page?.totalElements || 0;
            totalPages = apiData.page?.totalPages || Math.ceil(totalCharacters / pageSize);

            // Update the total pages display
            totalNum.textContent = totalPages;

            // Update the character count badge
            countBadge.textContent = `${totalCharacters} characters`;

            // Reset to page 1
            currentPage = 1;
            pageNum.textContent = currentPage;

            // Set the current page of characters
            allCharacters = filteredCharacters;

            // Show no results message if needed
            if (totalCharacters === 0) {
                noResults.classList.remove('hidden');
                container.classList.add('hidden');
                countBadge.textContent = 'No characters found';
            } else {
                noResults.classList.add('hidden');
                container.classList.remove('hidden');
                countBadge.textContent = `${totalCharacters} characters found`;
            }

            // Update species dropdown if needed
            if (!currentFilters.species) {
                updateSpeciesDropdown();
            }

            // Update pagination buttons
            prevBtn.disabled = currentPage <= 1 || isLoading;
            nextBtn.disabled = currentPage >= totalPages || isLoading;

            render();
        } catch (error) {
            console.error('Error applying filters:', error);
            container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error filtering characters. Please try again.</p>';
        } finally {
            isLoading = false;
            container.style.opacity = '1';
        }
    }


    // Function to render the current page based only on the current page's data in `allCharacters`
    function render() {
      try {
        console.log("Render called - current page:", currentPage, "total pages:", totalPages, "total characters:", totalCharacters);
        
        // Update total count display based on the overall total for the current filter set
        countBadge.textContent = `${totalCharacters} characters found`;

        // Update pagination display (uses overall totalPages for the current filter set)
        pageNum.textContent = currentPage;
        totalNum.textContent = totalPages; // Display the overall total pages

        // Enable/disable pagination buttons based on overall totalPages
        const currentPageNum = Number(currentPage);
        const totalPagesNum = Number(totalPages);
        
        // Force update button states immediately and after a short delay
        const updateButtonStates = () => {
          prevBtn.disabled = currentPageNum <= 1 || isLoading;
          nextBtn.disabled = currentPageNum >= totalPagesNum || isLoading;
          
          console.log('Pagination button states:', {
            prevDisabled: prevBtn.disabled,
            nextDisabled: nextBtn.disabled,
            currentPage: currentPageNum,
            totalPages: totalPagesNum,
            isLoading
          });
        };
        
        // Update immediately
        updateButtonStates();
        
        // And again after a short delay to ensure DOM updates
        setTimeout(updateButtonStates, 100);

        // Display "No Results" message if totalCharacters is 0 after fetch/filter
        noResults.classList.toggle('hidden', totalCharacters > 0);
        container.classList.toggle('hidden', totalCharacters === 0); // Hide grid if no results

        // Render character cards for the current page's items (allCharacters is always current page)
        if (totalCharacters > 0) {
            try {
                console.log("Rendering characters:", allCharacters.length);
                
                container.innerHTML = allCharacters.map(c => {
                  if (!c || !c.name) {
                      console.error("Invalid character data:", c);
                      return ''; // Skip invalid characters
                  }
                  
                  // Use local cached image if available, otherwise fallback to generic
                  let imageUrl = '/images/generic-character.jpg';
                  
                  // If we have a UID, try to use the local cached image
                  if (c.uid) {
                    // Format: /images/character-cache/[name-slug]-[uid].jpg
                    const nameSlug = c.name ? (typeof slugify !== 'undefined' ? slugify(c.name) : 'unknown') : 'unknown';
                    imageUrl = `/images/character-cache/${nameSlug}-${c.uid}.jpg`;
                  }
                  
                  // Create a slug that includes both the character name and UID
                  // Debug logging for slugify and character fields
                  if (typeof slugify === 'undefined') {
                    console.error("slugify is undefined in client-side render. This will cause a runtime error.");
                  } else {
                    console.log("slugify is defined:", slugify);
                  }
                  if (!c.uid) {
                    console.error("Character missing uid:", c);
                  }
                  if (!c.name) {
                    console.error("Character missing name:", c);
                  }
                  const nameSlug = c.name ? (typeof slugify !== 'undefined' ? slugify(c.name) : 'unknown') : 'unknown';
                  const slug = c.uid ? `${nameSlug}-${c.uid}` : nameSlug; // Combine name slug and UID

             return `
               <div class="character-card bg-space-black border border-starfleet-blue rounded-lg overflow-hidden transition-transform hover:scale-105">
                 <a href="/characters/${slug}/" class="block">
                   <div class="character-image aspect-square bg-gray-800">
                     <img
                       src="${imageUrl}"
                       alt="${c.name}"
                       class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition-opacity"
                       onerror="this.onerror=null; this.src='/images/generic-character.jpg';"
                     />
                   </div>
                   <div class="character-info p-3 border-t border-starfleet-blue">
                     <h3 class="text-white font-semibold truncate" title="${c.name}">${c.name}</h3>
                     <p class="text-gray-400 text-sm">${c.characterSpecies?.[0]?.name || c.species?.[0]?.name || 'Unknown'}</p>
                   </div>
                 </a>
               </div>
             `;
            }).join('');
          } catch (error) {
            console.error("Error in render function:", error);
            container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error rendering characters. Please check the console for details.</p>';
          }
        } else if (!isLoading) {
            // Ensure loading message is removed if there are truly no results
            container.innerHTML = '';
        }
        // Removed Memory Alpha image fetching logic
      } catch (error) {
        console.error("Error in main render function:", error);
        container.innerHTML = '<p class="text-center text-red-500 col-span-full">Error rendering page. Please check the console for details.</p>';
      }
    }

    // Debounced version of applying filters for search input
    const debouncedApplyFilters = debounce(applyFiltersAndFetch, 500);

    // Event Listeners - Trigger filter application
    speciesFilter.addEventListener('change', applyFiltersAndFetch);
    if (rankFilter) rankFilter.addEventListener('change', applyFiltersAndFetch);
    importantBox.addEventListener('change', applyFiltersAndFetch);
    keepBox.addEventListener('change', applyFiltersAndFetch);
    searchInput.addEventListener('input', debouncedApplyFilters); // Use debounced version for search

    // On initial load, update the species dropdown to match the initial filter state
    updateSpeciesDropdown();

    prevBtn.addEventListener('click', async () => {
      console.log('Previous button clicked', {
        currentPage,
        isLoading,
        disabled: prevBtn.disabled
      });
      
      if (Number(currentPage) > 1 && !isLoading) {
        try {
          const prevPage = Number(currentPage) - 1;
          console.log('Fetching previous page:', prevPage);
          await fetchPageIfNeeded(prevPage);
        } catch (error) {
          console.error('Error navigating to previous page:', error);
        }
      } else {
        console.log('Previous button condition not met', {
          currentPageCheck: Number(currentPage) > 1,
          loadingCheck: !isLoading
        });
      }
    });

    nextBtn.addEventListener('click', function() {
      // Convert to numbers for comparison
      const currentPageNum = Number(currentPage);
      const totalPagesNum = Number(totalPages);
      
      console.log('Next button clicked', {
        currentPage: currentPageNum,
        totalPages: totalPagesNum,
        isLoading,
        disabled: nextBtn.disabled,
        condition: currentPageNum < totalPagesNum
      });
      
      if (currentPageNum < totalPagesNum && !isLoading) {
        try {
          // Use the next page number
          const nextPage = currentPageNum + 1;
          console.log('Fetching next page:', nextPage);
          
          // Call fetchPageIfNeeded with the next page number
          // Use a timeout to ensure the UI updates before fetching the next page
          setTimeout(() => {
            fetchPageIfNeeded(nextPage);
          }, 100);
        } catch (error) {
          console.error('Error navigating to next page:', error);
        }
      } else {
        console.log('Next button condition not met', {
          currentPageCheck: currentPageNum < totalPagesNum,
          loadingCheck: !isLoading
        });
      }
    });

    // Initial Render on Load
    render(); // Render the initial data passed from the server
  });
</script>

<!-- No longer needed since we're using standard img tag -->

<style>
  .lcars-character-container {
    position: relative;
    overflow: hidden;
    border-radius: 6px;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  }
  
  .lcars-character-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 0 20px rgba(0, 178, 255, 0.4);
  }
  
  .character-image {
    position: relative;
  }
  
  .character-image img {
    transition: opacity 0.3s ease;
    opacity: 0.2;
  }
  
  .character-image img.loaded {
    opacity: 1;
  }
  
  .character-info {
    border-left: 3px solid var(--starfleet-gold);
    min-height: 80px;
  }
  
  .lcars-select, .lcars-input {
    transition: all 0.3s ease;
  }
  
  .lcars-select:focus, .lcars-input:focus {
    border-color: var(--starfleet-gold);
    outline: none;
    box-shadow: 0 0 10px rgba(0, 178, 255, 0.4);
  }
  
  .species-header {
    position: relative;
    overflow: hidden;
  }
  
  .species-header::after {
    content: '';
    position: absolute;
    left: -100%;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: sweep 3s infinite;
  }
  
  /* Pagination styles */
  .lcars-pagination {
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }
  
  .lcars-pagination button {
    position: relative;
    z-index: 2;
    transition: all 0.2s ease;
  }
  
  .lcars-pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .lcars-pagination::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 204, 0, 0.1), transparent);
    animation: sweep 2s infinite;
    z-index: 1;
  }
  
  @keyframes sweep {
    0% { left: -100%; }
    100% { left: 100%; }
  }
</style>